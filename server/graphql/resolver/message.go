package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"server/graphql/generated/model"
)

// PostMessage is the resolver for the postMessage field.
func (r *mutationResolver) PostMessage(ctx context.Context, input model.PostMessageInput) (*model.Message, error) {
	r.Mutex.Lock()
	defer r.Mutex.Unlock()
	for _, ch := range r.ChatID[int64(input.ChatID)] {
		ch <- &model.Message{
			ChatID: input.ChatID,
			UserID: input.UserID,
			Text:   input.Text,
		}
	}
	const postStatus = "sent"
	return &model.Message{
		ChatID: input.ChatID,
		Text:   input.Text,
		Type:   postStatus,
	}, nil
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context) ([]*model.Message, error) {
	return []*model.Message{
		{
			ChatID: 1,
			UserID: 1,
			Text:   "Hello World",
			Type:   "send",
		},
	}, nil
}

// GetMessage is the resolver for the getMessage field.
func (r *subscriptionResolver) GetMessage(ctx context.Context, chatID int64, userID int64) (<-chan *model.Message, error) {
	r.Mutex.Lock()
	defer r.Mutex.Unlock()

	ch := make(chan *model.Message, 1)
	message := <-ch
	MuserID := message.UserID
	if MuserID != userID {
		return nil, nil
	}

	r.ChatID[chatID] = append(r.ChatID[chatID], ch)
	go func() {
		<-ctx.Done()
		r.Mutex.Lock()
		defer r.Mutex.Unlock()
		for i, c := range r.ChatID[chatID] {
			if c == ch {
				r.ChatID[chatID] = append(r.ChatID[chatID][:i], r.ChatID[chatID][i+1:]...)
				break
			}
		}
	}()

	return ch, nil
}
